<!DOCTYPE html>
<html>
<head>
  <title>Lava Lamp Clock</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #141414;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
  </style>
</head>
<body>
  <script>
  let hourBalls = [];
let minuteBalls = [];
let secondBalls = [];
let lastHour = -1;
let lastMinute = -1;
let lastSecond = -1;

function setup() {
  createCanvas(800, 300);
  textAlign(CENTER, CENTER);
}

function draw() {
  background(20);
  
  // Get current time
  let h = hour();
  let m = minute();
  let s = second();
  
  // Convert to 12-hour format
  let h12 = h % 12;
  if (h12 === 0) h12 = 12;
  
  // Update balls if time changed
  if (h12 !== lastHour) {
    updateBalls(hourBalls, h12, 150, 150, 110, color(255, 80, 120));
    lastHour = h12;
  }
  if (m !== lastMinute) {
    updateBalls(minuteBalls, m, 400, 150, 110, color(80, 255, 150));
    lastMinute = m;
  }
  if (s !== lastSecond) {
    updateBalls(secondBalls, s, 650, 150, 110, color(80, 150, 255));
    lastSecond = s;
  }
  
  // Draw circular containers and balls
  drawCircleContainer(150, 150, 110, hourBalls);
  drawCircleContainer(400, 150, 110, minuteBalls);
  drawCircleContainer(650, 150, 110, secondBalls);
}

function updateBalls(ballArray, count, centerX, centerY, radius, ballColor) {
  // Calculate difference
  let currentCount = ballArray.length;
  let diff = count - currentCount;
  
  if (diff > 0) {
    // Add balls
    for (let i = 0; i < diff; i++) {
      ballArray.push(new LavaBall(centerX, centerY, radius, ballColor));
    }
  } else if (diff < 0) {
    // Remove balls (from the end)
    ballArray.splice(count);
  }
}

function drawCircleContainer(cx, cy, r, balls) {
  // Draw circle outline
  noFill();
  stroke(100, 100);
  strokeWeight(2);
  ellipse(cx, cy, r * 2);
  
  // Update and draw balls
  for (let ball of balls) {
    ball.updateCircle(cx, cy, r, balls);
    ball.display();
  }
}

class LavaBall {
  constructor(centerX, centerY, containerRadius, col) {
    this.containerX = centerX;
    this.containerY = centerY;
    this.containerRadius = containerRadius;
    
    // Start at random position within circle
    let angle = random(TWO_PI);
    let dist = random(0, containerRadius - 15);
    this.x = centerX + cos(angle) * dist;
    this.y = centerY + sin(angle) * dist;
    
    this.vx = random(-0.3, 0.3);
    this.vy = random(-0.3, 0.3);
    this.radius = 10;
    this.color = col;
    this.floatOffset = random(TWO_PI);
    this.floatSpeed = random(0.01, 0.02);
  }
  
  updateCircle(cx, cy, containerR, otherBalls) {
    // Lava lamp style floating movement
    this.floatOffset += this.floatSpeed;
    this.vx += sin(this.floatOffset) * 0.03;
    this.vy += cos(this.floatOffset * 0.7) * 0.05;
    
    // Very slow drift
    this.vy += random(-0.01, 0.02);
    
    // Heavy damping for viscous feel
    this.vx *= 0.98;
    this.vy *= 0.98;
    
    // Limit maximum speed for slow movement
    this.vx = constrain(this.vx, -0.8, 0.8);
    this.vy = constrain(this.vy, -1, 1);
    
    // Update position
    this.x += this.vx;
    this.y += this.vy;
    
    // Keep balls within circle boundary
    let distFromCenter = dist(this.x, this.y, cx, cy);
    let maxDist = containerR - this.radius;
    
    if (distFromCenter > maxDist) {
      // Push ball back inside circle
      let angle = atan2(this.y - cy, this.x - cx);
      this.x = cx + cos(angle) * maxDist;
      this.y = cy + sin(angle) * maxDist;
      
      // Bounce velocity
      this.vx *= -0.5;
      this.vy *= -0.5;
    }
    
    // Soft collision with other balls
    for (let other of otherBalls) {
      if (other !== this) {
        let d = dist(this.x, this.y, other.x, other.y);
        let minDist = this.radius * 2;
        
        if (d < minDist && d > 0) {
          // Gentle repulsion
          let angle = atan2(other.y - this.y, other.x - this.x);
          let force = (minDist - d) * 0.02;
          
          this.vx -= cos(angle) * force;
          this.vy -= sin(angle) * force;
          other.vx += cos(angle) * force;
          other.vy += sin(angle) * force;
        }
      }
    }
  }
  
  display() {
    noStroke();
    
    // Simple soft shadow
    fill(0, 30);
    ellipse(this.x + 2, this.y + 3, this.radius * 2);
    
    // Main ball - solid and clear
    fill(this.color);
    ellipse(this.x, this.y, this.radius * 2);
    
    // Simple highlight for depth
    fill(255, 40);
    ellipse(this.x - this.radius * 0.4, this.y - this.radius * 0.4, this.radius * 0.8);
  }
}

  </script>
</body>
</html>
